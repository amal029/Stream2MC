package org.IBM;

import net.sourceforge.gxl.*;
import java.io.*;
import java.util.*;


public class createPArch{
    private static StringBuffer readViaSSH(String arg){
	String command = "ssh "+arg+" cat /proc/cpuinfo > /tmp/cpuinfo";
	try{
	    Process p = Runtime.getRuntime().exec(command);
	    BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
	    String s;
	    while((s=stdError.readLine()) != null)
		System.out.println("Error: "+s);
	}
	catch(IOException e){e.printStackTrace();}
	return readFile("/tmp/cpuinfo");
    }

    private static StringBuffer readFile(String fileName){
	File file = new File(fileName);
	StringBuffer contents = new StringBuffer();
	BufferedReader reader = null;

	try {
	    reader = new BufferedReader(new FileReader(file));
	    String text = null;

	    // repeat until all lines is read
	    while ((text = reader.readLine()) != null) {
		contents.append(text)
		    .append(System.getProperty(
					       "line.separator"));
	    }
	} catch (FileNotFoundException e) {
	    e.printStackTrace();
	} catch (IOException e) {
	    e.printStackTrace();
	} finally {
	    try {
		if (reader != null) {
		    reader.close();
		}
	    } catch (IOException e) {
		e.printStackTrace();
	    }
	}
	return contents;
    }
    private static char isHtOrCoreOrNUMA(ArrayList<String> lp, ArrayList<Integer>pid, ArrayList<Integer>cores, ArrayList<Integer> s){
	int currpid = -1;
	int cpid = 0;
	char ret = 0x0000;
	boolean HT=false;
	int ccores =0;
	for(int e=0;e<lp.size();++e){
	    if(s.get(e) > cores.get(e)){
		HT=true;
		break;
	    }
	    else if(pid.get(e) > currpid){
		++cpid;
		ccores += cores.get(e);
	    }
	}
	if(cpid > 1)ret = 0x1; //It is NUMA, will have to look at /sys/devices/system/node
	if(ccores>cpid)ret|=0x2;//It is not NUMA
	if(HT)ret |= 0x4;//It is Hyper threaded
	return ret;
    }
    private static Integer tokenizeInteger(String s){
	Integer i = null;
	StringTokenizer token = new StringTokenizer(s,":");
	token.nextToken();
	i = new Integer(token.nextToken());
	return i;
    }
    private static ArrayList<ArrayList> getInfo(String string){
	Scanner scan = new Scanner(string);
	ArrayList<String> lProcessors = new ArrayList<String>();
	ArrayList<Integer> pID = new ArrayList<Integer>();
	ArrayList<Integer> cID = new ArrayList<Integer>();
	ArrayList<Integer> cores = new ArrayList<Integer>();
	ArrayList<Integer> siblings = new ArrayList<Integer>();
	ArrayList<ArrayList> list = new ArrayList<ArrayList>(10);
	try{
	    while(scan.hasNextLine()){
		String temp = scan.nextLine();
		if(temp.startsWith("processor"))
		    lProcessors.add(temp);
		else if(temp.startsWith("physical"))
		    pID.add(tokenizeInteger(temp));
		else if(temp.startsWith("core"))
		    cID.add(tokenizeInteger(temp));
		else if(temp.startsWith("cpu"))
		    cores.add(tokenizeInteger(temp));
		else if(temp.startsWith("siblings"))
		    siblings.add(tokenizeInteger(temp));
	    }
	    list.add(lProcessors); list.add(pID);
	    list.add(cID);list.add(cores);list.add(siblings);
	}
	catch(NoSuchElementException e){return list;}
	catch(IllegalStateException ie){ie.printStackTrace();}
	return list;
    }
    private static ArrayList<GXLNode> makeProcessorNodes(ArrayList<String> nodes,String machineName){
	ArrayList<GXLNode> list = new ArrayList<GXLNode>(10);
	for(int e=0;e<nodes.size();++e){
	    StringTokenizer token = new StringTokenizer(nodes.get(e),":");
	    token.nextToken();
	    String nodeNum = token.nextToken();
	    GXLNode node = new GXLNode(machineName+":"+"logicalProcessor:"+new StringTokenizer(nodeNum," ").nextToken());
	    node.setAttr("label",new GXLString(machineName+":"+"logicalProcessor:"+new StringTokenizer(nodeNum," ").nextToken()));
	    list.add(node);
	}
	return list;
    }
    /***
	TODO:
	1.) We need to know the number of cores within this machine the graph is a 
	flat graph
	We have a look at it hierarchically:
	a.) Look at the number of CPUs in the machine
	b.) We look at the number of cores within each CPU
	c.) Finally, we look at the number of hyper threads within the each core
    **/
    @SuppressWarnings("unchecked")
    private static GXLGraph completeMachineGraph(GXLGraph machine, String arg,String machineName){
	StringBuffer procFileBuffer = readViaSSH(arg);
	ArrayList<ArrayList> infoList = getInfo(procFileBuffer.toString());
	ArrayList<String> logicalProcessors = infoList.get(0); //First is the set of logicalProcessors
	ArrayList<Integer> pID = infoList.get(1);
	ArrayList<Integer> cID = infoList.get(2);
	ArrayList<Integer> cores = infoList.get(3);
	ArrayList<Integer> siblings = infoList.get(4);
	char ret = isHtOrCoreOrNUMA(logicalProcessors, pID, cores, siblings);
	ArrayList<GXLNode> nodes = makeProcessorNodes(logicalProcessors,machineName);

	for(int e=0;e<nodes.size();++e)
	    machine.add(nodes.get(e));
	return machine;
    }
    public static void main(String args[]){
	if(args.length < 1)
	    System.out.println("Usage: createPArch <user1@machine-name1 user2@machine-name2 ....>");
	try{
	    //Make the top-level single gxl graph and node
	    GXLDocument topDoc = new GXLDocument();
	    GXLGraph topGraph = new GXLGraph("topGraph");
	    topGraph.setEdgeMode("directed");
	    topGraph.setEdgeIDs(true);
	    GXLNode topNode = new GXLNode("topNode");
	    topGraph.add(topNode);
	    GXLGraph topNodeg = new GXLGraph("pArch");
	    topNodeg.setAttr("label",new GXLString("pArch"));
	    topNodeg.getAttr("label").setKind("graph");
	    topNode.add(topNodeg);
	    //Now make i args.length number of graphs
	    for(int i=0;i<args.length;++i){
		StringTokenizer token = new StringTokenizer(args[i],"@");
		token.nextToken();
		String machineName = token.nextToken();
		GXLNode node = new GXLNode("machine_"+machineName+"_node");
		node.setAttr("label",new GXLString("machine_"+machineName+"_node"));
		GXLGraph gr = new GXLGraph("machine_"+machineName+"_graph");
		gr.setAttr("label",new GXLString("machine_"+machineName+"_graph"));
		gr.getAttr("label").setKind("graph");
		gr.setEdgeMode("directed");
		gr.setEdgeIDs(true);
		gr = completeMachineGraph(gr,args[i],machineName);
		node.add(gr);
		topNodeg.add(node);
	    }
	    topDoc.getDocumentElement().add(topGraph);
	    topDoc.write(new File("pArch.gxl"));
	}
	catch(IOException e){e.printStackTrace();}
	catch(NoSuchElementException es){es.printStackTrace();}
    }
}
